<!doctype html>
<html lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Ford Property Services ‚Ä¢ Photo Notes</title>
  <meta name="theme-color" content="#0b1220" />

  <!-- Strong cache discouragement (helps, but SW is the real culprit) -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">

  <!-- jsPDF -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <style>
    :root{
      --bg:#0b1220; --card:#101a33; --text:#e7eefc; --muted:#a9b7d3;
      --line:rgba(255,255,255,.14); --shadow:0 10px 30px rgba(0,0,0,.35);
      --blue:#4aa3ff; --good:#22c55e; --bad:#ef4444;
      --r:18px; --r2:14px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 20% -10%, rgba(74,163,255,.22), transparent 60%),
        radial-gradient(900px 650px at 100% 0%, rgba(34,163,94,.12), transparent 55%),
        var(--bg);
    }
    header{
      position:sticky; top:0; z-index:20;
      background:rgba(11,18,32,.88);
      backdrop-filter: blur(10px);
      border-bottom:1px solid var(--line);
    }
    .wrap{max-width:1100px;margin:0 auto;padding:14px 16px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .top{justify-content:space-between}
    .title{font-weight:900}
    .back{color:#9ecbff;text-decoration:none;font-weight:900}
    main{max-width:1100px;margin:0 auto;padding:16px}
    .card{
      border:1px solid var(--line);
      border-radius: var(--r);
      background: linear-gradient(180deg, rgba(16,26,51,.92), rgba(12,23,48,.92));
      box-shadow: var(--shadow);
      padding:14px;
    }
    label{display:block;font-size:12px;color:var(--muted);margin:10px 0 6px}
    input,textarea,select{
      width:100%;
      background: rgba(0,0,0,.25);
      border:1px solid var(--line);
      color:var(--text);
      border-radius:14px;
      padding:10px 12px;
      outline:none;
      font-size:15px;
    }
    textarea{min-height:92px;white-space:pre-wrap;resize:vertical}
    .grid{display:grid;gap:12px;margin-top:12px}
    @media(min-width:860px){.grid{grid-template-columns: 1.05fr .95fr}}
    .btnrow{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
    button{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color:var(--text);
      padding:10px 14px;
      border-radius:14px;
      font-weight:900;
      cursor:pointer;
    }
    button.primary{border-color: rgba(74,163,255,.45); background: rgba(74,163,255,.14)}
    button.good{border-color: rgba(34,197,94,.55); background: rgba(34,197,94,.12)}
    button.bad{border-color: rgba(239,68,68,.55); background: rgba(239,68,68,.10)}
    button:disabled{opacity:.55;cursor:not-allowed}
    .hint{font-size:12px;color:var(--muted);margin-top:10px;line-height:1.35}
    .pill{
      font-size:12px;color:var(--muted);
      border:1px solid rgba(255,255,255,.12);
      padding:6px 10px;border-radius:999px;
      background: rgba(255,255,255,.04);
      white-space:nowrap;
    }

    /* GPS Address row */
    .addrRow{display:flex;gap:10px;align-items:center}
    .addrRow input{flex:1;min-width:220px}
    .smallBtn{padding:10px 12px;border-radius:14px;white-space:nowrap}

    /* Photo list */
    .list{display:flex;flex-direction:column;gap:12px;margin-top:12px}
    .item{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      border-radius: var(--r2);
      overflow:hidden;
    }
    .itemTop{display:flex;gap:10px;padding:12px;align-items:flex-start}
    .thumb{
      width:92px;height:92px;border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      object-fit:cover;
      flex:0 0 auto;
    }
    .meta{flex:1;min-width:0}
    .meta .t{margin:0;font-weight:900;font-size:14px}
    .meta .s{margin:4px 0 8px;font-size:12px;color:var(--muted)}
    .itemBtns{display:flex;gap:8px;flex-wrap:wrap;padding:0 12px 12px}
    .small{padding:9px 12px;border-radius:12px;font-size:13px}
  </style>
</head>

<body>
<header>
  <div class="wrap row top">
    <div class="row" style="gap:12px">
      <div class="title">Ford Property Services ‚Ä¢ Photo Notes</div>
      <span class="pill" id="speechPill">Dictation: checking‚Ä¶</span>
    </div>
    <a class="back" href="../dashboard/">‚Üê Dashboard</a>
  </div>
</header>

<main>
  <div class="grid">
    <section class="card">
      <label>Property Address</label>
      <div class="addrRow">
        <input id="address" placeholder="e.g., 12 High Street, London" />
        <button id="btnGps" class="primary smallBtn" type="button">üìç Use GPS</button>
      </div>

      <!-- Full address picker -->
      <div id="houseWrap" style="display:none; margin-top:8px;">
        <label style="margin:0 0 6px;">Select Address (if needed)</label>
        <select id="houseSelect"></select>
        <div class="hint" id="houseHint" style="margin-top:6px;"></div>
      </div>

      <div class="hint" id="gpsHint" style="margin-top:6px;"></div>

      <div class="row" style="gap:12px">
        <div style="flex:1;min-width:220px">
          <label>Date</label>
          <input id="date" type="date" />
        </div>
        <div style="flex:1;min-width:220px">
          <label>Operative (optional)</label>
          <input id="operative" placeholder="e.g., Ben Ford" />
        </div>
      </div>

      <div class="btnrow">
        <!-- ‚úÖ Camera + Gallery -->
        <button id="btnCamera" class="primary">üì∑ Camera</button>
        <button id="btnGallery" class="primary">üñºÔ∏è Gallery</button>

        <button id="btnPdf" class="good">üßæ Generate PDF</button>
        <button id="btnShare" class="primary" disabled>üì§ Share PDF (WhatsApp)</button>
        <button id="btnClear" class="bad">üóëÔ∏è Clear</button>
      </div>

      <div class="hint" id="status">
        Add photos, dictate notes per photo, then generate and share a PDF.
      </div>

      <!-- ‚úÖ Separate inputs -->
      <input id="cameraInput" type="file" accept="image/*" capture="environment" multiple hidden>
      <input id="galleryInput" type="file" accept="image/*" multiple hidden>
    </section>

    <section class="card">
      <div class="row" style="justify-content:space-between">
        <strong>Photos & Notes</strong>
        <span class="pill" id="countPill">0 photos</span>
      </div>
      <div class="list" id="list"></div>
    </section>
  </div>
</main>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  // IMPORTANT: stop stale PWA behaviour in THIS folder
  // This does NOT wipe localStorage/IndexedDB; it only removes SW + HTTP caches.
  async function killServiceWorkersAndCachesOnce(){
    try{
      if ('serviceWorker' in navigator) {
        const regs = await navigator.serviceWorker.getRegistrations();
        for (const r of regs) {
          await r.unregister().catch(()=>{});
        }
      }
      if (window.caches) {
        const keys = await caches.keys();
        await Promise.all(keys.map(k => caches.delete(k).catch(()=>{})));
      }
    }catch(e){}
  }

  // -------- GPS helpers (full address dropdown) --------
  async function reverseGeocodeOSM(lat, lon){
    const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}&zoom=18&addressdetails=1`;
    const res = await fetch(url, { headers: { "Accept":"application/json", "Accept-Language":"en-GB" } });
    if(!res.ok) throw new Error("Reverse geocode failed");
    return await res.json();
  }
  function setGpsHint(msg){ const el = $("gpsHint"); if(el) el.textContent = msg || ""; }
  function setHouseHint(msg){ const el = $("houseHint"); if(el) el.textContent = msg || ""; }

  function pickTown(a){
    return a.town || a.city || a.village || a.suburb || a.county || "";
  }
  function buildAddress(houseNumber, road, town, postcode){
    const line1 = [houseNumber, road].filter(Boolean).join(" ").trim();
    return [line1, town, postcode].filter(Boolean).join(", ").trim();
  }

  async function fetchNearbyFullAddresses({road, town, postcode, lat, lon}){
    // small viewbox around the location to keep it on the correct road
    const d = 0.01; // ~1km-ish
    const left = lon - d, right = lon + d, top = lat + d, bottom = lat - d;

    const params = new URLSearchParams({
      format: "jsonv2",
      addressdetails: "1",
      limit: "60",
      countrycodes: "gb",
      street: road || "",
      city: town || "",
      postalcode: postcode || "",
      viewbox: `${left},${top},${right},${bottom}`,
      bounded: "1"
    });

    const url = `https://nominatim.openstreetmap.org/search?${params.toString()}`;
    const res = await fetch(url, { headers: { "Accept":"application/json", "Accept-Language":"en-GB" } });
    if(!res.ok) throw new Error("Nearby address search failed");
    const results = await res.json();

    const seen = new Set();
    const list = [];

    for(const r of results){
      const a = r.address || {};
      const hn = (a.house_number || "").trim();
      const rRoad = (a.road || a.pedestrian || a.footway || "").trim();
      if(!hn) continue;
      if(road && rRoad && rRoad.toLowerCase() !== road.toLowerCase()) continue;

      const t = pickTown(a) || town || "";
      const pc = (a.postcode || "").trim() || postcode || "";
      const full = buildAddress(hn, rRoad || road, t, pc);
      if(!full) continue;

      const key = full.toLowerCase();
      if(seen.has(key)) continue;
      seen.add(key);

      list.push({
        label: full,
        house: hn,
        road: rRoad || road,
        town: t,
        postcode: pc
      });
    }

    // Sort by numeric house then alpha
    list.sort((A,B)=>{
      const na = parseInt(A.house,10), nb = parseInt(B.house,10);
      if(!isNaN(na) && !isNaN(nb) && na !== nb) return na - nb;
      return A.label.localeCompare(B.label, "en-GB", {numeric:true, sensitivity:"base"});
    });

    return list.slice(0, 40);
  }

  function showAddressPicker(addresses, preselectLabel){
    const wrap = $("houseWrap");
    const sel = $("houseSelect");
    if(!wrap || !sel) return;

    sel.innerHTML = "";

    const opt0 = document.createElement("option");
    opt0.value = "";
    opt0.textContent = "Select the correct address‚Ä¶";
    sel.appendChild(opt0);

    addresses.forEach((a) => {
      const opt = document.createElement("option");
      opt.value = a.label;
      opt.textContent = a.label;
      sel.appendChild(opt);
    });

    wrap.style.display = addresses.length ? "block" : "none";

    if(preselectLabel){
      const found = addresses.find(x => x.label.toLowerCase() === preselectLabel.toLowerCase());
      if(found) sel.value = found.label;
    }
  }
  // -------- end GPS helpers --------

  const STORE = "fps_photo_notes_v2_store";
  const VERSION_STAMP = "v2.0.3-gps-fulladdr-camgal"; // bump when you update

  function setStatus(msg){ $("status").textContent = msg; }

  function todayISO(){ return new Date().toISOString().slice(0,10); }
  function ukDate(d){
    return new Date(d).toLocaleDateString("en-GB",{day:"2-digit",month:"2-digit",year:"numeric"});
  }
  function ukTime(d){
    return new Date(d).toLocaleTimeString("en-GB",{hour:"2-digit",minute:"2-digit"});
  }

  let state = { address:"", date: todayISO(), operative:"", photos: [], gps:null };
  let pdfBlob = null;
  let pdfFile = null;
  let pdfName = "";

  function save(){ localStorage.setItem(STORE, JSON.stringify(state)); }
  function load(){
    const raw = localStorage.getItem(STORE);
    if (raw) {
      try { state = JSON.parse(raw); } catch {}
    }
    $("address").value = state.address || "";
    $("date").value = state.date || todayISO();
    $("operative").value = state.operative || "";
    state.date = $("date").value;
  }

  $("address").addEventListener("input", e => { state.address = e.target.value; save(); });
  $("date").addEventListener("change", e => { state.date = e.target.value; save(); });
  $("operative").addEventListener("input", e => { state.operative = e.target.value; save(); });

  // GPS button
  $("btnGps").onclick = () => {
    if(!navigator.geolocation){
      alert("GPS not supported on this device/browser.");
      return;
    }

    setGpsHint("Getting your location‚Ä¶");
    setHouseHint("");
    $("houseWrap").style.display = "none";
    $("btnGps").disabled = true;

    navigator.geolocation.getCurrentPosition(async (pos) => {
      try{
        const lat = pos.coords.latitude;
        const lon = pos.coords.longitude;

        setGpsHint("Finding road/postcode‚Ä¶");
        const data = await reverseGeocodeOSM(lat, lon);
        const a = data.address || {};

        const hn = (a.house_number || "").trim();
        const road = (a.road || a.pedestrian || a.footway || "").trim();
        const town = pickTown(a);
        const postcode = (a.postcode || "").trim();

        // Fill what we can immediately
        const base = buildAddress(hn, road, town, postcode) || (data.display_name || "");
        if(base){
          $("address").value = base;
          state.address = base;
          state.gps = { lat, lon, ts: new Date().toISOString(), road, town, postcode, house: hn || null };
          save();
        }

        if(!road){
          setGpsHint("GPS found, but no road name returned. You can type the address manually.");
          return;
        }

        setGpsHint("Looking for nearby full addresses‚Ä¶");
        const addresses = await fetchNearbyFullAddresses({ road, town, postcode, lat, lon });

        if(addresses.length){
          showAddressPicker(addresses, base);
          setGpsHint(hn
            ? "GPS found an address. If it‚Äôs slightly off, pick the correct one below."
            : "GPS couldn‚Äôt find an exact house number ‚Äî pick the correct address below.");

          $("houseSelect").onchange = () => {
            const chosen = $("houseSelect").value;
            if(!chosen) return;

            $("address").value = chosen;
            state.address = chosen;

            const picked = addresses.find(x => x.label === chosen);
            state.gps = {
              ...(state.gps || {}),
              lat, lon,
              ts: new Date().toISOString(),
              road: picked?.road || road,
              town: picked?.town || town,
              postcode: picked?.postcode || postcode,
              house: picked?.house || hn || null
            };
            save();

            setHouseHint("Selected address applied.");
          };
        } else {
          setGpsHint(hn
            ? "GPS found an address."
            : "Couldn‚Äôt find nearby addresses for this road. Type the number manually if needed.");
        }

      }catch(err){
        console.warn(err);
        setGpsHint("Couldn‚Äôt get address list. Try again in a moment.");
        alert("Couldn‚Äôt convert GPS to nearby addresses (may be rate-limited). Try again shortly.");
      }finally{
        $("btnGps").disabled = false;
      }
    }, (err) => {
      console.warn(err);
      $("btnGps").disabled = false;
      setGpsHint("GPS permission denied or unavailable.");
      alert("GPS not available. Please allow location permission and try again.");
    }, {
      enableHighAccuracy: true,
      timeout: 12000,
      maximumAge: 60000
    });
  };

  // Dictation
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  const dictationSupported = !!SpeechRecognition;
  $("speechPill").textContent = dictationSupported ? "Dictation: supported" : "Dictation: not supported";

  function render(){
    $("countPill").textContent = `${state.photos.length} photo${state.photos.length===1?"":"s"}`;
    const list = $("list");
    list.innerHTML = "";

    if (!state.photos.length) {
      const div = document.createElement("div");
      div.className = "hint";
      div.textContent = "No photos yet. Tap ‚ÄúCamera‚Äù or ‚ÄúGallery‚Äù.";
      list.appendChild(div);
      return;
    }

    state.photos.forEach((p, idx) => {
      const item = document.createElement("div");
      item.className = "item";
      item.innerHTML = `
        <div class="itemTop">
          <img class="thumb" src="${p.img}" alt="Photo ${idx+1}">
          <div class="meta">
            <p class="t">Photo ${idx+1}</p>
            <p class="s">${ukDate(p.ts)} ${ukTime(p.ts)}</p>
            <textarea placeholder="Notes‚Ä¶">${p.note || ""}</textarea>
          </div>
        </div>
        <div class="itemBtns">
          <button class="small primary" ${dictationSupported ? "" : "disabled"} data-dict="${p.id}">üéôÔ∏è Dictate</button>
          <button class="small" disabled data-stop="${p.id}">‚èπÔ∏è Stop</button>
          <button class="small bad" data-del="${p.id}">üóëÔ∏è Delete</button>
        </div>
      `;

      const ta = item.querySelector("textarea");
      ta.addEventListener("input", () => {
        p.note = ta.value;
        save();
        pdfBlob = pdfFile = null;
        $("btnShare").disabled = true;
      });

      item.querySelector(`[data-del="${p.id}"]`).onclick = () => {
        state.photos = state.photos.filter(x => x.id !== p.id);
        save();
        pdfBlob = pdfFile = null;
        $("btnShare").disabled = true;
        render();
      };

      const btnDict = item.querySelector(`[data-dict="${p.id}"]`);
      const btnStop = item.querySelector(`[data-stop="${p.id}"]`);

      if (dictationSupported) {
        btnDict.onclick = () => {
          const rec = new SpeechRecognition();
          rec.lang = "en-GB";
          rec.interimResults = true;
          rec.continuous = false;

          btnDict.disabled = true;
          btnStop.disabled = false;
          setStatus("Listening‚Ä¶ speak your note.");

          const existing = (ta.value || "").trim();
          let finalText = "";

          btnStop.onclick = () => { try{ rec.stop(); }catch{} };

          rec.onresult = (e) => {
            let interim = "";
            for (let i = e.resultIndex; i < e.results.length; i++){
              const t = e.results[i][0].transcript;
              if (e.results[i].isFinal) finalText += t;
              else interim += t;
            }
            const combined = (existing ? existing + " " : "") + (finalText + interim).trim();
            ta.value = combined.trim();
            p.note = ta.value;
            save();
          };

          rec.onerror = () => {
            setStatus("Dictation error. Try again.");
            btnDict.disabled = false;
            btnStop.disabled = true;
          };

          rec.onend = () => {
            setStatus("Ready.");
            btnDict.disabled = false;
            btnStop.disabled = true;
          };

          try { rec.start(); } catch {
            setStatus("Couldn‚Äôt start dictation. Try again.");
            btnDict.disabled = false;
            btnStop.disabled = true;
          }
        };
      }

      list.appendChild(item);
    });
  }

  async function fileToDataURL(file){
    return new Promise((resolve, reject) => {
      const r = new FileReader();
      r.onload = () => resolve(r.result);
      r.onerror = reject;
      r.readAsDataURL(file);
    });
  }

  // ‚úÖ Camera + Gallery handlers
  $("btnCamera").onclick = () => $("cameraInput").click();
  $("btnGallery").onclick = () => $("galleryInput").click();

  async function handleFiles(e){
    const files = Array.from(e.target.files || []);
    if (!files.length) return;

    setStatus(`Adding ${files.length} photo(s)‚Ä¶`);
    for (const f of files) {
      if (!f.type.startsWith("image/")) continue;
      const dataURL = await fileToDataURL(f);
      state.photos.push({
        id: (crypto.randomUUID ? crypto.randomUUID() : String(Date.now()) + Math.random().toString(16).slice(2)),
        img: dataURL,
        note: "",
        ts: new Date().toISOString()
      });
    }
    save();
    pdfBlob = pdfFile = null;
    $("btnShare").disabled = true;
    setStatus("Photos added.");
    render();
    e.target.value = "";
  }

  $("cameraInput").addEventListener("change", handleFiles);
  $("galleryInput").addEventListener("change", handleFiles);

  $("btnPdf").onclick = async () => {
    if (!state.address.trim()) { alert("Add the property address first."); return; }
    if (!state.photos.length) { alert("Add at least one photo first."); return; }

    setStatus("Generating PDF‚Ä¶");

    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ orientation:"p", unit:"mm", format:"a4" });

    const pageW = doc.internal.pageSize.getWidth();
    const pageH = doc.internal.pageSize.getHeight();
    const margin = 12;
    const contentW = pageW - margin*2;

    doc.setFont("helvetica","bold"); doc.setFontSize(14);
    doc.text("PHOTO NOTES REPORT", margin, 16);

    doc.setFont("helvetica","normal"); doc.setFontSize(10);
    doc.text(`Date: ${ukDate(state.date)}   App: ${VERSION_STAMP}`, margin, 22);

    doc.setFont("helvetica","bold"); doc.text("Property Address:", margin, 30);
    doc.setFont("helvetica","normal"); doc.text(state.address, margin, 36, { maxWidth: contentW });

    if (state.operative.trim()) {
      doc.setFont("helvetica","bold"); doc.text("Operative:", margin, 46);
      doc.setFont("helvetica","normal"); doc.text(state.operative, margin + 22, 46);
    }

    if (state.gps && typeof state.gps.lat === "number" && typeof state.gps.lon === "number") {
      doc.setFont("helvetica","normal"); doc.setFontSize(9);
      doc.text(`GPS: ${state.gps.lat.toFixed(6)}, ${state.gps.lon.toFixed(6)}`, margin, 52);
    }

    doc.setDrawColor(200); doc.setLineWidth(0.2);
    doc.line(margin, 56, pageW - margin, 56);

    let y = 64;

    async function dataURLToImage(dataURL){
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = dataURL;
      });
    }

    for (let i=0; i<state.photos.length; i++){
      const p = state.photos[i];

      if (y > pageH - 30) { doc.addPage(); y = 18; }

      doc.setFont("helvetica","bold"); doc.setFontSize(11);
      doc.text(`Photo ${i+1}`, margin, y);
      doc.setFont("helvetica","normal"); doc.setFontSize(9);
      doc.text(`${ukDate(p.ts)} ${ukTime(p.ts)}`, pageW - margin, y, { align:"right" });
      y += 5;

      const img = await dataURLToImage(p.img);
      const imgWpx = img.naturalWidth || img.width;
      const imgHpx = img.naturalHeight || img.height;

      const maxImgH = 95;
      let drawW = contentW;
      let drawH = (imgHpx / imgWpx) * drawW;
      if (drawH > maxImgH) {
        drawH = maxImgH;
        drawW = (imgWpx / imgHpx) * drawH;
      }
      const xImg = margin + (contentW - drawW)/2;

      doc.setDrawColor(180);
      doc.roundedRect(margin, y, contentW, drawH + 2, 2, 2);
      doc.addImage(p.img, "JPEG", xImg, y+1, drawW, drawH);
      y += drawH + 10;

      const note = (p.note || "").trim() || "‚Äî";
      doc.setFont("helvetica","bold"); doc.setFontSize(10);
      doc.text("Notes:", margin, y);
      y += 6;
      doc.setFont("helvetica","normal"); doc.setFontSize(10);

      const lines = doc.splitTextToSize(note, contentW);
      const boxH = Math.max(14, lines.length * 5 + 6);

      if (y + boxH > pageH - 12) { doc.addPage(); y = 18; }
      doc.setDrawColor(180);
      doc.roundedRect(margin, y-4, contentW, boxH, 2, 2);
      doc.text(lines, margin+3, y+2);
      y += boxH + 10;
    }

    pdfBlob = doc.output("blob");
    const safeAddr = state.address.replace(/[^\w\s-]/g,"").trim().replace(/\s+/g,"-").slice(0,40);
    pdfName = `Photo-Notes-${safeAddr}-${state.date}.pdf`;

    pdfFile = new File([pdfBlob], pdfName, { type:"application/pdf" });

    $("btnShare").disabled = false;
    setStatus("PDF generated. Tap Share PDF and choose WhatsApp.");
  };

  $("btnShare").onclick = async () => {
    if (!pdfFile) { alert("Generate the PDF first."); return; }

    if (navigator.canShare && navigator.canShare({ files:[pdfFile] })) {
      try{
        await navigator.share({ title: "Photo Notes", text: "Photo notes report attached.", files:[pdfFile] });
        setStatus("Shared.");
        return;
      }catch(e){}
    }

    const url = URL.createObjectURL(pdfBlob);
    const a = document.createElement("a");
    a.href = url;
    a.download = pdfName || "photo-notes.pdf";
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 2000);
    alert("Your browser can‚Äôt share files directly. The PDF was downloaded‚Äîattach it in WhatsApp.");
    setStatus("PDF downloaded.");
  };

  $("btnClear").onclick = () => {
    if (!confirm("Clear all photos and notes for this report?")) return;
    state.photos = [];
    save();
    pdfBlob = pdfFile = null;
    $("btnShare").disabled = true;
    setStatus("Cleared.");
    render();
  };

  // INIT
  (async () => {
    await killServiceWorkersAndCachesOnce();
    load();
    if (!$("date").value) $("date").value = todayISO();
    render();
    setStatus("Ready.");
  })();

})();
</script>
</body>
</html>
